<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-99999</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup
enum transition {
 //The different kinds of transitions
 color_fade,
 cross_fade,
 slide_left,
 slide_right,
 slide_up,
 slide_down,
 push_left,
 push_right,
 push_up,
 push_down,
 maximize,
 minimize
}

//Transition variables
next_room = room; //The room to transition to.
kind = transition.color_fade; //The selected transition.
length = 30; //The transition time in steps.
color = c_black; //The transition color (if needed).
jam = true; //Whether or not to jam the keyboard and mouse - by doing this, no keyboard or mouse input will be recogniced during the transition.

current_step = 0; //Counting how far into the transition we are.

/*
 Here we create two new surfaces, and draw our application
 surface onto the first of them. This works as a screenshot
 of the current room. 
 
 The second surface is only needed for some transition types.
*/

surface_from = surface_create(surface_get_width(application_surface),surface_get_height(application_surface));
surface_to = surface_create(surface_get_width(application_surface),surface_get_height(application_surface));

surface_set_target(surface_from);
draw_clear(c_black);
draw_enable_alphablend(false);
draw_set_colour_write_enable(true,true,true,false);
draw_surface(application_surface,0,0);
draw_set_colour_write_enable(true,true,true,true);
draw_enable_alphablend(true);
surface_reset_target();

//We want to make all our foregrounds invisible, or else they will be drawn on top of the transition.
for(i=0;i&lt;8;i++){
 back_vis[i] = background_visible[i];
 if background_foreground[i] == true {
  background_visible[i] = false;
 }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clean up
//We free our surfaces from memory, and re-enables our foregrounds.
surface_free(surface_from);
surface_free(surface_to);
for(i=0;i&lt;8;i++){
 background_visible[i] = back_vis[i];
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Transition
current_step++; //We add one to our counter.

//If our counter surpasses our transition-length we destroy the object, and thereby ends the transition.
if current_step &gt; length {
 instance_destroy();
}

//By using io_clear in the begin step event we stop input from having effect.
if jam {
 io_clear();
}

/*
 If any of the surfaces are not existing for some reason, we simply skip the
 transition by going to the next room (if not already there) and destroying
 this object.
*/
if !surface_exists(surface_from) || !surface_exists(surface_to) {
 if room != next_room {
  room_goto(next_room);
 }
 instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Re-disable foregrounds
for(i=0;i&lt;8;i++){
 back_vis[i] = background_visible[i];
 if background_foreground[i] {
  background_visible[i] = false;
 }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update surface
/*
 If our kind is one of the kinds needing
 our second surface, we make sure to draw and update
 the surface.
 This will update the surface every step, thus animate
 the surface.
*/
if kind == transition.push_left || kind == transition.push_right || kind == transition.push_up || kind == transition.push_down {
 surface_set_target(surface_to);
 draw_clear(c_black);
 draw_enable_alphablend(false);
 draw_set_colour_write_enable(true,true,true,false);
 draw_surface(application_surface,0,0);
 draw_set_colour_write_enable(true,true,true,true);
 draw_enable_alphablend(true);
 surface_reset_target();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Transition
//We create teh temporary variables containing the gui width and height for easy access.
var __gui_width = display_get_gui_width();
var __gui_height = display_get_gui_height();
/*
 Below are all the transitions' individual code blocks.
 You can easily add your own kinds by adding a macro
 and by adding its code in here.
 First we check which kind is in use, then we check if
 we should go to the next room (according to the timing
 needed in the particular kind), and then we draw the
 transition, either by drawing the surfaces, or by drawing
 on top of the screen.
*/

//Color fade
if kind == transition.color_fade {
 if room != next_room &amp;&amp; current_step == ceil(length/2) {
  room_goto(next_room);
 }
 
 draw_set_alpha(1-abs(current_step-length/2)/(length/2));
 draw_set_color(color);
 draw_rectangle(0,0,__gui_width,__gui_height,false);
 draw_set_alpha(1);
}
//Cross fade
if kind == transition.cross_fade {
 if room != next_room {
  room_goto(next_room);
 }
 
 draw_surface_stretched_ext(surface_from,0,0,__gui_width,__gui_height,c_white,1-current_step/length);
}
//Slide left
if kind == transition.slide_left {
 if room != next_room {
  room_goto(next_room);
 }
 
 draw_surface_stretched_ext(surface_from,-current_step/length*__gui_width,0,__gui_width,__gui_height,c_white,1);
}
//Slide right
if kind == transition.slide_right {
 if room != next_room {
  room_goto(next_room);
 }
 
 draw_surface_stretched_ext(surface_from,current_step/length*__gui_width,0,__gui_width,__gui_height,c_white,1);
}
//Slide up
if kind == transition.slide_up {
 if room != next_room {
  room_goto(next_room);
 }
 
 draw_surface_stretched_ext(surface_from,0,-current_step/length*__gui_height,__gui_width,__gui_height,c_white,1);
}
//Slide down
if kind == transition.slide_down {
 if room != next_room {
  room_goto(next_room);
 }
 
 draw_surface_stretched_ext(surface_from,0,current_step/length*__gui_height,__gui_width,__gui_height,c_white,1);
}
//Push left
if kind == transition.push_left {
 if room != next_room {
  room_goto(next_room);
 }
 draw_surface_stretched_ext(surface_to,(1-current_step/length)*__gui_width,0,__gui_width,__gui_height,c_white,1);
 draw_surface_stretched_ext(surface_from,-current_step/length*__gui_width,0,__gui_width,__gui_height,c_white,1);
}
//Push right
if kind == transition.push_right {
 if room != next_room {
  room_goto(next_room);
 }
 draw_surface_stretched_ext(surface_to,(-1+current_step/length)*__gui_width,0,__gui_width,__gui_height,c_white,1);
 draw_surface_stretched_ext(surface_from,current_step/length*__gui_width,0,__gui_width,__gui_height,c_white,1);
}
//Push up
if kind == transition.push_up {
 if room != next_room {
  room_goto(next_room);
 }
 draw_surface_stretched_ext(surface_to,0,(1-current_step/length)*__gui_height,__gui_width,__gui_height,c_white,1);
 draw_surface_stretched_ext(surface_from,0,-current_step/length*__gui_height,__gui_width,__gui_height,c_white,1);
}
//Push down
if kind == transition.push_down {
 if room != next_room {
  room_goto(next_room);
 }
 draw_surface_stretched_ext(surface_to,0,(-1+current_step/length)*__gui_height,__gui_width,__gui_height,c_white,1);
 draw_surface_stretched_ext(surface_from,0,current_step/length*__gui_height,__gui_width,__gui_height,c_white,1);
}
//Minimize
if kind == transition.minimize {
 if room != next_room {
  room_goto(next_room);
 }
 
 draw_surface_stretched_ext(surface_from,__gui_width/2*current_step/length,__gui_height/2*current_step/length,__gui_width-current_step/length*__gui_width,__gui_height-current_step/length*__gui_height,c_white,1);
}
//Maximize
if kind == transition.maximize {
 if room != next_room {
  room_goto(next_room);
 }
 
 draw_surface_stretched_ext(surface_from,-__gui_width/2*current_step/length,-__gui_height/2*current_step/length,__gui_width+current_step/length*__gui_width,__gui_height+current_step/length*__gui_height,c_white,1-current_step/length);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw foregrounds
//We draw the foregrounds manually, since these are not drawn to the application surface.
for(i=0;i&lt;8;i++){
 if background_foreground[i] &amp;&amp; back_vis[i] {
  draw_background(background_index[i],background_x[i],background_y[i]);
  draw_background(background_index[i],background_x[i],background_y[i]);
 }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
